= NodeJS IPC
:author: Sylvain Leroux
:pin: -
:revnumber: 0.1
:revdate: 2022-04-20T14:19:27+01:00
:keywords: NodeJS, IPC

[.teaser]
The NodeJS asynchronous programming model is the _de facto_ standard for NodeJS applications. In that model, your application is single-threaded. Still, several tasks are interleaved, so execution may continue with another part of the code while one task is blocked (for example, waiting for some I/O operation to complete). But sometimes, you would like to take benefits from a multicore system. Or, and it was what motivated this writing, you have to deal with JavaScript modules that do not play well together because they modify the prototype of the standard object in an incompatible manner. In that case, you may prefer to isolate the bad JS citizens in their own instance of the V8 JavaScript engine to prevent unwanted side effects. That's what we will talk about in this article.

== An example
This section will illustrate why I needed to isolate some modules in their own instance of the V8 engine. If you are only focused on spawning new NodeJS processes and establishing a communication between the two V8 instances, you may skip this section. 

So, as I said previously, I had an application where I needed to import two modules. Unfortunately, they modified the Object's prototype in two mutually incompatible manners. 

I reduced that use case into the two poorly written modules:
* The `rogue1` module provides some interface to a hypothetic SQL database.
* And the `rogue2` module provides some helper functions to produce HTML documents.

https://github.com/YesIKnowIT/Blog/blob/master/2022/node-ipc/code/rogue1.js

https://github.com/YesIKnowIT/Blog/blob/master/2022/node-ipc/code/rogue2.js

Apparently, there is no link between these two modules, and you can genuinely think they will work independently of one another. So, here is some test file to check that:

https://github.com/YesIKnowIT/Blog/blob/master/2022/node-ipc/code/main1.js

Now, look what appends when NodeJS execute this code:

```
sh$ node main1.js
asParagraph(str): <p>Sylvain&#039;s test string</p>
addToDict(str): Sending: INSERT INTO DICTIONARY(entry) VALUES ( 'Sylvain''s test string' );
asParagraph(str): <p>Sylvain''s test string</p>
```

The code contains two identical calls to the `asParagraph` function provided by the `rogue1` module. Surprisingly enough, those two calls produce two different results! Why that? If you look closely at the code of the two rogue modules, you will see each one modifies the String's prototype by attaching a new method. In one module, to escape the string following the SQL rules. In the other module, to escape the string following the HTML escape rules.
Unluckily,  the authors of both these libraries chose the same name for this new method: `$escape`. It's not hard to understand that, when loading the `rogue2` module, the HTML `$escape` method is overwritten by the SQL `$escape` method. And after that, the HTML helper functions provided by `rogue1` call the wrong `$escape` method and return garbage.

Library writers: That's why you should use [symbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) to attach new properties to existing objects' prototypes. Symbols are guaranteed to be uniques, and you may have avoided that pitfall by using them. That being said, it is usually not recommended to modify the standard object's prototypes. Think twice if you plan to do that!

== Using a worker process
As noted in the above sidebar, the real solution would be to rewrite the modules to avoid attaching a new method to the String's prototype. But in my case, both were large third-party libraries, and a rewrite was out of the question. The solution was to isolate each library in its own V8 instance so they would no longer conflict. 

=== Introducing `fork` and `spawnSync`
The bare minimum to do that is illustrated in the following example. I split the program into two files, `main` and `worker`, with the goal of running each part in its own process. The `rogue2` module usage being now confined to the worker process, it can no longer conflict with the modules loaded in the main process:

https://github.com/YesIKnowIT/Blog/blob/master/2022/node-ipc/code/main2.js

https://github.com/YesIKnowIT/Blog/blob/master/2022/node-ipc/code/worker.js

All the code related to the `rogue2` module has now moved into the `worker` module. And instead of using it directly, the main program uses the `child_process.fork` function to load and run `worker.js` in a new _independent_ V8 instance. Let's try that:

```
sh$ node main2.js
asParagraph(str): <p>Sylvain&#039;s test string</p>
asParagraph(str): <p>Sylvain&#039;s test string</p>
addToDict(str): Sending: INSERT INTO DICTIONARY(entry) VALUES ( '/home/sylvain/Projects/Blog/2022/node-ipc/code/worker' );
```

There are two things to notice here:

* First, and that was expected, all calls to `asParagraph` from the main process now return identical results. The `rogue2` module no longer conflicts with that.
* Second, the lines in the output do not appear in the same order as previously: our application is now made of two independent processes running in parallel and scheduled at the goodwill of the operating system. If you consider the time needed to start the second V8 instance, the main program has largely the time to execute many instructions before the worker process starts.

Let's try to slow down things a little by adding delays so we can confirm both processes run in parallel. NodeJS does not provide a command to pause execution. So we will use a trick here: using the function `spawnSync` provided by the `child_process` module, we will spawn the OS-provided command `sleep` to create a delay. There are two major differences between `fork` we used previously and `spawnSync`:

* Whereas `fork` load and execute a JavaScript module in a new V8 instance, `spawnSync` allows you to run an arbitrary command just like if it was started from a shell.
* `spawnSync`, just as the `Sync` suffix suggests, will execute the child process synchronously. That means the parent process is suspended until the completion of the child process.

If you're familiar with other programming languages, `spawnSync` is very close to the [`system(3)`](https://man7.org/linux/man-pages/man3/system.3.html) function provided by the standard C library.


https://github.com/YesIKnowIT/Blog/blob/master/2022/node-ipc/code/main3.js

```
$ node main3.js
asParagraph(str): <p>Sylvain&#039;s test string</p>
addToDict(str): Sending: INSERT INTO DICTIONARY(entry) VALUES ( '/home/sylvain/Projects/Blog/2022/node-ipc/code/worker' );
asParagraph(str): <p>Sylvain&#039;s test string</p>
```

Now, if we run the program with the added delays,  we can see the same sequence of events as we had initially. Once again, without any conflict between the rogue libraries since they were loaded in independent processes.

Of course, you won't rely on delays to order the operations in a real application, not to mention it would suspend NodeJS' asynchronous events processing. So we need a way for the parent process to submit a job to the worker process and a way for the worker to signal the completion of a task to its parent. That will be the topic of the next section.

=== Parent-child communication
By now, you should be convinced the parent and the child processes run into independent V8 instances. Let's go a little bit further by rewriting our application to use the event-based IPC provided by NodeJS to establish two-way communication between the parent and the child process.

When using the `child_process.fork` function, NodeJS returns an object representing the child process. This object gives you access, among others, to an event-based communication channel between the parent and the child process. On its side, the child process can use the `process` global object to handle the incoming messages from its parent:

https://github.com/YesIKnowIT/Blog/blob/master/2022/node-ipc/code/worker-async.js

The core work is now done in the `message` event handler. Upon receiving a request from its parent process, the worker process does its job, then sends the result back to the sender. I wrapped the processing into a `setTimeout` call with a random delay to simulate asynchronous operations in the worker process.


Parent's side, we use a similar technique: an event handler is installed to deal with the worker process' responses. I also added some extra logic to count the number of requests handled to trigger the child process' termination when we're done.


https://github.com/YesIKnowIT/Blog/blob/master/2022/node-ipc/code/main-async.js


Once the handler is installed, I send the requests to the worker process using `worker.send`. And it's done: We can now process data asynchronously while keeping the poorly written modules isolated in their own V8 instance:

```
sh$ node main-server.js
parent sending message [ '0', "Sylvain's test string A" ]
parent sending message [ '1', "Sylvain's test string B" ]
parent sending message [ '2', "Sylvain's test string C" ]
parent sending message [ '3', "Sylvain's test string D" ]
worker receiving message [ '0', "Sylvain's test string A" ]
worker receiving message [ '1', "Sylvain's test string B" ]
worker receiving message [ '2', "Sylvain's test string C" ]
worker receiving message [ '3', "Sylvain's test string D" ]
worker done processing message [ '3', "Sylvain's test string D" ]
parent receiving [
  '3',
  "Sending: INSERT INTO DICTIONARY(entry) VALUES ( 'Sylvain''s test string D' );"
]
parent asParagraph(str): <p>Sylvain&#039;s test string D</p>
worker done processing message [ '2', "Sylvain's test string C" ]
parent receiving [
  '2',
  "Sending: INSERT INTO DICTIONARY(entry) VALUES ( 'Sylvain''s test string C' );"
]
parent asParagraph(str): <p>Sylvain&#039;s test string C</p>
worker done processing message [ '0', "Sylvain's test string A" ]
parent receiving [
  '0',
  "Sending: INSERT INTO DICTIONARY(entry) VALUES ( 'Sylvain''s test string A' );"
]
parent asParagraph(str): <p>Sylvain&#039;s test string A</p>
worker done processing message [ '1', "Sylvain's test string B" ]
parent receiving [
  '1',
  "Sending: INSERT INTO DICTIONARY(entry) VALUES ( 'Sylvain''s test string B' );"
]
parent asParagraph(str): <p>Sylvain&#039;s test string B</p>
parent terminating worker
worker exiting
```

=== What to do next?
In the pure textbook tradition, I left error handling as an exercise to the reader.

More interestingly, you could try to convert from the traditional callback programming style used here to a `Promise`-based solution. As a suggestion, you may consider using `Promise.all` to terminate the worker process once all requests have been handled.

== Conclusion
The standard `child_process` module provides several ways to spawn new processes from NodeJS, either to run external commands or to load and execute a JavaScript module in an independent V8 instance. Some of these functions exist both in asynchronous and synchronous forms. I encourage you to explore the official documentation to learn more about them and see how they allow you to interact with or gather data from the child process.

