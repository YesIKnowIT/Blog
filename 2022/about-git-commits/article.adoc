= About git commits
:author: Sylvain Leroux
:pin: -
:revnumber: v0.1
:revdate: 2022-05-28T17:19:46+02:00
:keywords: Git

[.teaser]
This article is about...

== Introduction
We use Git every day.
But what Git does exactly when we stage a file, or commit a change set to a repository?
How Git store our data?
We will try to answer those questions by looking behind the scene to see how Git manage our data.

In this article, I assume you have a practical experience with Git and you are familiar with the `git add` and `git commit` commands.
The demonstration were done using a Linux Ubuntu system.
But you can reproduce similar manipulations on any system supporting Git, like OpenBSD or MacOS.

== Initial setup

Let's make a little experimentation:

----
sh$ mkdir exp-1-1       # 1
sh$ cd exp-1-1          # 2
sh$ git init exp-1-1    # 3
Initialized empty Git repository in exp-1-1/.git/
sh$ cd exp-1-1/         # 4
sh$ find .git > list1   # 5
----

1. Let's create a new directory to work into
2. And change the working directory to that one.
   For now it's an ordinary directory. I has noting special that would make it a Git repository.
   That will change at the next step.
3. Initialise the curent directory as a Git repository.
   Git inform us it has created the hidden `.git` directory.
   That's where Git will store all the data it need to work.
   It Git's little private corner if you want.
   Normally, you don't look into that directory, except mayby to change the configuration by editing `.git/config`.
   But today, we will be a little bit more curious.
4. We will keep track of the files in the `.git` directory so we have a basis of comparaison to later check if new files where created.


=== Staging a data file

In you day to day job, you interact with the index, also known as the stage area, primarily through the `git add`/`git rm` commands.
But what do the do really?
To look at that we will now create a new file.
For now, it is just basic file manipulation, and Git is absolutly not concerned by our work as it will inform you if you use the `git status` command:

----
sh$ echo "Hello world" > hello.txt
sh$ ls
hello.txt  list1
sh$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        hello.txt
        list1

nothing added to commit but untracked files present (use "git add" to track)
----

Let's now track our newly created file:

----
sh$ git add hello.txt
sh$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

        new file:   hello.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        list1
----

Apparenty, things have changed for Git. It's now tracking the `hello.txt` file.
But how does that reflect in the `.git` directory?

----
sh$ find .git > list2
sh$ diff list1 list2
19a20
> .git/index
20a22,23
> .git/objects/80
> .git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7
----

Ah, ah! The new files have appeared:
* `.git/index`
* `.git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7`

The `index` file is a binary file used by Git to keep track of the file staged for addition (or removal, by the way) in the next commit.
It's a binary file, so we won't examine it manually.
But Git provides some commands to interact directly with that file. We will see that later.

For now, let's concentrate to the second file. The one with that strange name made of a serie of digit and letters from `a` to `f`.
It sits in the `.git/object` directory -- sometimes known as the Git object database.
That's where Git store all its data in Zlib compressed files.


This one in readable, and it's content may surprise you:

----
sh$ file .git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7
.git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7: zlib compressed data
sh$ zlib-flate -uncompress < .git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7
blob 12Hello world
----

It's our file! Well almost. Git added a header made of the word `blob` and the size in bytes of the of the data.
Not visible in the output of the `zlib-flate` command, there is also a https://en.wikipedia.org/wiki/Null_character[null character] between the header and the content of the file.
You can see it by piping the output of `zlib-flate` to the `cat -v` command:

----
sh$ zlib-flate -uncompress < .git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7 | cat -v
blob 12^@Hello world
----

The `^@` is the https://en.wikipedia.org/wiki/Caret_notation[caret notation] for the null character.


But this is not the only surprise.
Do you remember the strange name of this file?
It looked like a random string, but if you tried the same experiment on your own computer, you may have noticed the file has the same name on your machine!

If fact, the name of the file is the SHA1 https://en.wikipedia.org/wiki/Hash_function[hash] of its content:

----
sh$ zlib-flate -uncompress < .git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7 | sha1sum
802992c4220de19a90767f3000a79a31b98d0df7  -
----

In the Git vocabulary, we also say it's the Object Identifier (OID) of the file.
Since the OID is directly computed from the content of the file, you may also sometimes read Git is a https://en.wikipedia.org/wiki/Content-addressable_storage[content adressable] filesystem.


Until now I used common tools to reverse engeneer the git blog file.
But, those are inner detail, subject to change between versiions of Git.
So Git provides commands to deal with these data files without requiring any extra tool.
For example, to see the content of a Git object knowing its OID, you can use `git show`.
It returns the content of the file, with the Git-specific header removed:

----
sh$ git show 802992c4220de19a90767f3000a79a31b98d0df7
Hello world
----

You can also query the type, data length and content an object using the `git cat-file` command:

----
sh$ git cat-file -t 802992c4220de19a90767f3000a79a31b98d0df7
blob
sh$ git cat-file -s 802992c4220de19a90767f3000a79a31b98d0df7
12
sh$ git cat-file -p 802992c4220de19a90767f3000a79a31b98d0df7
Hello world
----

=== The index
It was a long time ago now, but you may still remember after staging a file, we saw another file created: `.git/index`.
Git stores the current staging information in that file.
The index is not part of the git object database, so you can't examine it using `git show` or `git cat-file`.
I need to introduce yet another command for that purpose: the `git ls-files` command.
Let's take a look at that:

----
sh$ git ls-files --stage
100644 802992c4220de19a90767f3000a79a31b98d0df7 0       hello.txt
----

Various information are returned by `git ls-files --stage` for each staged file:
* A set of permissions bits for the file.
* The OID the references the content of the file.
* A "stage level". In normal use case, you should always see 0 here.
* Finally, the name of the file

In some sense, you may see the index file like a file system's directory data structure, whose entries points to the location of the data associated with each file name.

=== Updateing a file in the index
Imagine now I'm not satisfied with the current content of the `hello.txt` file. Actually, I forgot the puntuations. Let's fix that:

----
sh$ echo "Hello, world!" > hello.txt
sh$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

        new file:   hello.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   hello.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        list1
        list2
        tmp
----

The intersting part here is we have a version of `hello.txt` staged.
But we also have a different version of the file, having the same name, in the working directory.

You may already have encountered this situation in your daily Git work.
The solution is simply to add the new version of the file into the index:

----
sh$ git add hello.txt
sh$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

        new file:   hello.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        list1
        list2
        tmp
----

Problem solved: the most recent version of `hello.txt` is now staged, ready for commit.
But did you ever wonder what appened to the previously staged verion or the file?
Was it overwritten by the new version? Is it definitivelly lost?

To answer these questions, let's see what exactly has changed as far as Git is concerned:

----
find .git > list3
sh$ diff list1 list3
19a20
> .git/index
20a22,25
> .git/objects/80
> .git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7
> .git/objects/af
> .git/objects/af/5626b4a114abcb82d63db7c8082c3c4756e51b
----
Obviously, the previous version was not lost, since the corresponding blob is still present in the Git's object database.
But we may see Git has added a new object: the blob corresponding to the updated version of our file.
Now both the new and the previous version of the file coexists in the database.
So, how does Git know which version it should commmit?
By looking into the index.

But you don't have to take my words for granted:

----
sh$ git show af5626b4a114abcb82d63db7c8082c3c4756e51b
Hello, world!
sh$ git ls-files --stage
100644 af5626b4a114abcb82d63db7c8082c3c4756e51b 0       hello.txt
----

The key point to remember here is, when you stage a new version of a file, the previous version is not lost.
A new blob is created into the object database, and the index is updated to point to the new version of the file.

=== What about the commits?

OK, we have staged files. Found they were stored as blob object in the Git's object database.
We also learned the index is updated to references the staged object through their OID.
But what happens when we commit our changes?

----
sh$ git commit -m "Initial commit"
[master (root-commit) aa89f17] Initial commit
 1 file changed, 1 insertion(+)
 create mode 100644 hello.txt
----
As a quick note, you remember the permissions bits we saw when using `git ls-files`.
We can see them in the output prodced by `git commit`.

----
find .git > list4
sh$ diff list1 list4
5a6
> .git/refs/heads/master
19a21
> .git/index
20a23,28
> .git/objects/80
> .git/objects/80/2992c4220de19a90767f3000a79a31b98d0df7
> .git/objects/af
> .git/objects/af/5626b4a114abcb82d63db7c8082c3c4756e51b
> .git/objects/aa
> .git/objects/aa/89f1701dc5409bb63228f1e9f64aa7ff0bba17
22a31,32
> .git/objects/ec
> .git/objects/ec/947e3dd7a7752d078f1ed0cfde7457b21fef58
23a34,39
> .git/COMMIT_EDITMSG
> .git/logs
> .git/logs/HEAD
> .git/logs/refs
> .git/logs/refs/heads
> .git/logs/refs/heads/master
----
This time, many this have changed!

First, we have not one, but two new entries in the object database. This calls for a closer examination:

----
sh$ git cat-file -t ec947e3dd7a7752d078f1ed0cfde7457b21fef58
tree
sh$ git cat-file -p ec947e3dd7a7752d078f1ed0cfde7457b21fef58
100644 blob af5626b4a114abcb82d63db7c8082c3c4756e51b    hello.txt
----

Apparently, we have a new type of object in our database: a tree.
And that tree is nothing more than a copy of the index at the time of the commit.
Speaking of commit, let's examine the other new object created in the database:

----
sh$ git cat-file -t aa89f1701dc5409bb63228f1e9f64aa7ff0bba17
commit
sh$ git cat-file -p aa89f1701dc5409bb63228f1e9f64aa7ff0bba17
tree ec947e3dd7a7752d078f1ed0cfde7457b21fef58
author Sylvain Leroux <sylvain@chicoree.fr> 1653860652 +0200
committer Sylvain Leroux <sylvain@chicoree.fr> 1653860652 +0200

Initial commit

----

Yes: it's the commit object.  And now the picture is complete.
The commit object stores the commit message, some metadata and most important, a pointer to a tree object, which list the content of
the staging area at the moment of the commit, each file entry pointing to the acual content of the file.

By the way, speaking of the index, what's its content after the commit?

----
sh$ git ls-files --stage
100644 af5626b4a114abcb82d63db7c8082c3c4756e51b 0       hello.txt
----

It hasn't changed! One thing to remember is a Git commit is a complete snapshot of the staging area.
Not just a record of the changes that occured since the previous commit (as other revision control system might do).

But since Git index the data files ("blob") by the hash of their content, it will not duplicate the data that hasn't changed between commits.

=== Branches
Something else has changed in the `.git` directory after our commit. A new entry was added in the `.git/ref` subdirectory.
We didn't talk about it until know, so let's take the time to examine it in detail:

----
sh$ cat .git/refs/heads/master
aa89f1701dc5409bb63228f1e9f64aa7ff0bba17
----
Yes, a branch is nothing more than a pointer to a commit in the object store.

=== The HEAD

If you read aven a little about Git, you might have heard of the HEAD.
It's just a reference maintained by Git to know which commit your current working tree is based on.
And indeed, there's nothing more here:

----
sh$ cat .git/HEAD
ref: refs/heads/master
----

== The case of the subdirectory

Until now, we simply added files sitting at the root of the working directory.
But how does Git handle sub-directories?

To examine that, we will create a new directory and add a file inside that directory.
Then we will use `git add` to stage that newly added file.

----
sh$ mkdir fr
sh$ echo "Bonjour, le monde!" > fr/bonjour.txt
sh$ git add fr/bonjour.txt
----

We used the `git add` command. So, the new file is staged -- in other word, Git has created a new blob object to store the content of the file and the index was updated.
Let's look at the index first this time:

----
sh$ git ls-files --stage
100644 84745588cb61f0d9e15a41144af8daf30caf20d4 0       fr/bonjour.txt
100644 af5626b4a114abcb82d63db7c8082c3c4756e51b 0       hello.txt
----

You may notice the index does not handle files in subdirectory differently than files sitting at the root of the working tree.
Simple, the new file is recorded in the index with its path.

By looking at the index first, we also can see the OID of the blob containing our new data.
I let the command name blank in the code block below as you should now be able to use the correct Git command to examine that object:

----
sh$ git  ....  84745588cb61f0d9e15a41144af8daf30caf20d4
Bonjour, le monde!
----

For memory, the HEAD still reference the commit we made in the first part of this article:

----
sh$ git rev-parse HEAD
aa89f1701dc5409bb63228f1e9f64aa7ff0bba17
sh$ git cat-file -p aa89f1701dc5409bb63228f1e9f64aa7ff0bba17
tree ec947e3dd7a7752d078f1ed0cfde7457b21fef58
author Sylvain Leroux <sylvain@chicoree.fr> 1653860652 +0200
committer Sylvain Leroux <sylvain@chicoree.fr> 1653860652 +0200

Initial commit
----

We have some change staged, let's apply the mantra "commit often":

----
sh$ git commit -m "Second commit"
[master 89adbd7] Second commit
 1 file changed, 1 insertion(+)
 create mode 100644 fr/bonjour.txt
sh$ git log --format=oneline
89adbd7ea23b4394d34d2bf26a83d6721d3f9e94 (HEAD -> master) Second commit
aa89f1701dc5409bb63228f1e9f64aa7ff0bba17 Initial commit
----

The `git log` command gives us a lot of informations:
First, the HEAD still references the `master` branch

----
sh$ cat .git/HEAD
ref: refs/heads/master
----

Then, the branch master now references the commit `89adbd7ea23b4394d34d2bf26a83d6721d3f9e94`

----
tree 43541e6608e3172081f67d469a133e1262b723c6
parent aa89f1701dc5409bb63228f1e9f64aa7ff0bba17
author Sylvain Leroux <sylvain@chicoree.fr> 1653943012 +0200
committer Sylvain Leroux <sylvain@chicoree.fr> 1653943012 +0200

Second commit
----

You may notice this commit record one more piece of information compared to the initial one:
there is now a `parent` field that references the previous commit.
This is using that field that Git remembers in which order the commits are chained.

We may also see by examining the commit object that a new tree object was created with OID `43541e6608e3172081f67d469a133e1262b723c6`.
You probably have an idea of what we will do now:

----
sh$ git cat-file -p 43541e6608e3172081f67d469a133e1262b723c6
040000 tree eba5b0c78c7a3f9cdfcf13ca10121527312003b5    fr
100644 blob af5626b4a114abcb82d63db7c8082c3c4756e51b    hello.txt
----

This time again, things are a little bit diffrent compared to our first commit.
You can see the tree object contains now two entries.
One for the file `hello.txt` we already had and whose content is stored as a blob object.
But there is now another entry pointing toward a tree object.

Here Git really behave like a filesystem and adopt a hierarchical tree structure.
The tree `fr` whose OID is `eba5b0c78c7a3f9cdfcf13ca10121527312003b5` being like a sub-directory of the repository.
Like previously, you show now be familiar enough with that operation to complete the code block below with the right command to examine the content of the new tree.

----
sh$ git  ........ ..  eba5b0c78c7a3f9cdfcf13ca10121527312003b5
100644 blob 84745588cb61f0d9e15a41144af8daf30caf20d4    bonjour.txt
----

== Moving things

I could multiply the examples, and, as a matter of fact, I encourage you to continue this little game of reverse-engeneering on Git by yourself.
I will conclude with a last example, this time to show you what happens when you move files around in your repository:

----
sh$ mkdir en
sh$ cp hello.txt en/
sh$ git rm hello.txt
rm 'hello.txt'
sh$ git add en/hello.txt
sh$ git commit
Aborting commit due to empty commit message.
sh$ git commit -m "Third commit"
[master 478b7ac] Third commit
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename hello.txt => en/hello.txt (100%)
----

This time I moved the `hello.txt` file into its own subdirectory.
I took the long way, using file copy, then `git add` and `git rm`.
But look in the output of the the `git commit` command: despite my efforts, Git was not fooled and properly understood the file has moved.
It somehow detectected it was not a new file creation, but a move.

Take a fiew minutes break here to think how Git could have reached to that conclusion.


To solve that mystery, we will apply the same procedure as above:
examine the commit object, then the tree(s), to finally descend down to the blobs:

----
sh$ git log --format=oneline
478b7aceb5bf619290dc7dfac4118bef494023a1 (HEAD -> master) Third commit
89adbd7ea23b4394d34d2bf26a83d6721d3f9e94 Second commit
aa89f1701dc5409bb63228f1e9f64aa7ff0bba17 Initial commit


sh$ git cat-file -p 478b7aceb5bf619290dc7dfac4118bef494023a1
tree af6aba37e10abbcfc78d57d8777118d4cfa8620b
parent 89adbd7ea23b4394d34d2bf26a83d6721d3f9e94
author Sylvain Leroux <sylvain@chicoree.fr> 1653944421 +0200
committer Sylvain Leroux <sylvain@chicoree.fr> 1653944421 +0200

Third commit


sh$ git cat-file -p af6aba37e10abbcfc78d57d8777118d4cfa8620b
040000 tree ec947e3dd7a7752d078f1ed0cfde7457b21fef58    en
040000 tree eba5b0c78c7a3f9cdfcf13ca10121527312003b5    fr
----

At this point things have changed a little.
We still have the `fr` entry refrencing the tree object `eba5b0c78c7a3f9cdfcf13ca10121527312003b5` (which is the same as in the previous commit).
But we now have another tree for the second subdirectory we created this time.

And guess what? If you examine the content of that tree object, you will see it refrences the exact same blob as before:

----
sh$ git cat-file -p ec947e3dd7a7752d078f1ed0cfde7457b21fef58
100644 blob af5626b4a114abcb82d63db7c8082c3c4756e51b    hello.txt
----

Since Git implements a content addressable filesystem, as long as the content of the file `hello.txt` does not change, it still has the same OID.
So its relatively easy for Git to detact that in a previous commit the blob OID `af5626b4a114abcb82d63db7c8082c3c4756e51b` was n the top-level tree object,
and that now its in a sub-tree, and conclude the file has moved.

== Conclusion
And this ends our tour behind the scene of Git. You may continue your exploration by examining the object database of one of your repository.
Probably the database will contain many many more objects than the example I showed you today.
But Starting from a commit or from the index, you should be able to find your way back to the content of any file on the repository.
And doing so, you would basiccaly do by hand the same job as the `git checkout` command.

Since we have seen a lot of new Git command in this article, I left you with a quick recap.
As always, I hope you liked this article, and I'm looking forward to reding you on Twitter!

`git add`::Store in the object database a blog corresponding to the added file, and update the index to refrence that blob
`git cat-file`::Given its OID, display the content or metadata of an object
`git commit`::Capture a snapshot of the index by creating a commit and eventually one or everal tree in the object databas
`git log`::Display information about a commit and its ancestors by following the parent reference of each commit.
`git ls-files`::Show information about files in the index (or working tree)
`git rev-parse`::Show the OID of a commit. Useful to defernce HEAD of a branch name notably
`git rm`::Remove the reference to a file from the index. Do not remove any object from the database
`git show`::Given its OID, display the content of an object. Support more formatting options than `git cat-file`
